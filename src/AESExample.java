// package sci.crypt.course.crypto;
// import Rijndael_Algorithm;
import java.security.SecureRandom;
import java.math.BigInteger;

import java.io.*;
import java.util.*;

/**
 * @author Xunhua Wang (wangxx@jmu.edu)
 * @date 09/27/2014
 * All rights reserved
 */

public class AESExample {

    public void testAESImplementationTwo () {
        try {
            int times = 1000;

            byte[] inKey = new byte[16];
	    byte[] cbcIV = new byte[16];

            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            random.nextBytes(inKey);	// This generates a random AES-128 key
            random.nextBytes(cbcIV);	// This generates a random IV

            // populate the plaintext
            String textString = "abcdefghijklmnop";
            byte[] inText = textString.getBytes();

	    for (int i=0; i < 16; i++) inText[i] = (byte) (inText[i] ^ cbcIV[i]); // According to CBC, this is how we use the IV

            long time1 = 0, time2 = 0, time3 = 0, time4 = 0;

	    Object roundKeys = null;
            byte[] cipherText = null;

            for (int i=0; i < times; i++) // To get more accurate timing results, we have to warm up your CPU a little bit.
					// This is the whole purpose of this line of code
					// This warm-up is NOT needed in your programming or real-world applications
                roundKeys = Rijndael_Algorithm.makeKey (Rijndael_Algorithm.ENCRYPT_MODE, inKey);

	    // Now, we are ready and let's start the business
	    System.out.println (System.getProperty ("line.separator") + "Testing AES implementation two ......");

            time1 = System.currentTimeMillis(); // Start the timing clock
	    //
	    // Why do we do this 1000 times? If you choose to measure the time to perform a 
	    // 	single key expansion and encryption, you will always get 0, as this process is too fast
	    //
            for (int i=0; i < times; i++) { // for measuring time. If you use 1 instead, you will always get 0 in time3
                // AES key schedule
                roundKeys = Rijndael_Algorithm.makeKey (Rijndael_Algorithm.ENCRYPT_MODE, inKey);

                // AES encryption, the first parameter is 128-bit
                // plaintext, the second parameter is 0, and the
                // third parameter is the round keys generated by the
                // key schedule call
                cipherText = Rijndael_Algorithm.blockEncrypt2 (inText, 0, roundKeys);
	    }
	    time2 = System.currentTimeMillis(); // end the timing clock
	    time3 = time2 - time1; // This is the time, in milliseconds, elapsed in this 1000 BLOCK encryptions

	    //
	    // Now it is time to decrypt the ciphertext
	    //
	    byte[] recoveredText = null;
	    time1 = System.currentTimeMillis();	// Start the timing clock
	    for (int i=0; i < times; i++) {
                roundKeys = Rijndael_Algorithm.makeKey (Rijndael_Algorithm.DECRYPT_MODE, inKey);
                recoveredText = Rijndael_Algorithm.blockDecrypt2 (cipherText, 0, roundKeys);

            }
            time2 = System.currentTimeMillis(); // End the timing clock
	    time4 = time2 - time1; // This is the time, in milliseconds, elapsed in this 1000 BLOCK decryptions

            // How do we know whether the decryption works? We have to check the recovered cleartext
	    for (int i=0; i < 16; i++) recoveredText[i] = (byte) (recoveredText[i] ^ cbcIV[i]);
            String recoveredString = new String (recoveredText);
            if (!recoveredString.equals (textString)) {
            	System.out.println ("Decryption does NOT work!");
            } else
            	System.out.println ("Decryption worked beautifully and recovered the original plaintext!");

            System.out.println ("It takes blockEncrypt2 " + time3 + " milliseconds to run AES-128 key scheduling & ENcryption " + times + " times");
            System.out.println ("It takes blockDecrypt2 " + time4 + " milliseconds to run AES-128 key scheduling & DEcryption " + times + " times");

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public void testAESSlowerImplementationOne () {
        try {
            int times = 1000;

            byte[] inKey = new byte[16];
	    byte[] cbcIV = new byte[16];

            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            random.nextBytes(inKey);	// This generates a random AES-128 key
            random.nextBytes(cbcIV);	// This generates a random IV

            // populate the plaintext
            String textString = "abcdefghijklmnop";
            byte[] inText = textString.getBytes();

	    for (int i=0; i < 16; i++) inText[i] = (byte) (inText[i] ^ cbcIV[i]); // According to CBC, this is how we use the IV

            long time1 = 0, time2 = 0, time3 = 0, time4 = 0;

	    Object roundKeys = null;
            byte[] cipherText = null;

            for (int i=0; i < times; i++) // To get more accurate timing results, we have to warm up your CPU a little bit.
					// This is the whole purpose of this line of code
					// This warm-up is NOT needed in your programming or real-world applications
                roundKeys = Rijndael_Algorithm.makeKey (Rijndael_Algorithm.ENCRYPT_MODE, inKey);

	    // Now, we are ready and let's start the business
	    System.out.println (System.getProperty ("line.separator") + "Testing AES implementation one, which is SLOWER ......");
            time1 = System.currentTimeMillis(); // Start the timing clock
	    //
	    // Why do we do this 1000 times? If you choose to measure the time to perform a 
	    // 	single key expansion and encryption, you will always get 0, as this process is too fast
	    //
            for (int i=0; i < times; i++) { // for measuring time. If you use 1 instead, you will always get 0 in time3
                // AES key schedule
                roundKeys = Rijndael_Algorithm.makeKey (Rijndael_Algorithm.ENCRYPT_MODE, inKey);

                // AES encryption, the first parameter is 128-bit
                // plaintext, the second parameter is 0, and the
                // third parameter is the round keys generated by the
                // key schedule call
                cipherText = Rijndael_Algorithm.blockEncrypt (inText, 0, roundKeys);
	    }
	    time2 = System.currentTimeMillis(); // end the timing clock
	    time3 = time2 - time1; // This is the time, in milliseconds, elapsed in this 1000 BLOCK encryptions

	    //
	    // Now it is time to decrypt the ciphertext
	    //
	    byte[] recoveredText = null;
	    time1 = System.currentTimeMillis();	// Start the timing clock
	    for (int i=0; i < times; i++) {
                roundKeys = Rijndael_Algorithm.makeKey (Rijndael_Algorithm.ENCRYPT_MODE, inKey); 
			// Yes, you have to specify the ENCRYPTION_MODE for this slower implementation
                recoveredText = Rijndael_Algorithm.blockDecrypt (cipherText, 0, roundKeys);

            }
            time2 = System.currentTimeMillis(); // End the timing clock
	    time4 = time2 - time1; // This is the time, in milliseconds, elapsed in this 1000 BLOCK decryptions

            // How do we know whether the decryption works? We have to check the recovered cleartext
	    for (int i=0; i < 16; i++) recoveredText[i] = (byte) (recoveredText[i] ^ cbcIV[i]);
            String recoveredString = new String (recoveredText);
            if (!recoveredString.equals (textString)) {
            	System.out.println ("Decryption does NOT work!");
            } else
            	System.out.println ("Decryption worked beautifully and recovered the original plaintext!");

            System.out.println ("It takes blockEncrypt " + time3 + " milliseconds to run AES-128 key scheduling & ENcryption " + times + " times");
            System.out.println ("It takes blockDecrypt " + time4 + " milliseconds to run AES-128 key scheduling & DEcryption " + times + " times");

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static String convertToString (byte[] data) {
	char[] _hexArray = {'0', '1', '2', '3', '4', '5','6', '7', '8',
			    '9', 'A', 'B', 'C', 'D', 'E', 'F'};

	StringBuffer sb = new StringBuffer();

	for (int i=0; i <data.length; i++) {
		sb.append("" + _hexArray[(data[i] >> 4) & 0x0f] + _hexArray[data[i] & 0x0f]);
	}

	return sb.toString();
    }

    public static void main (String[] args) {
    	System.out.println("Starting...");
    	System.out.println("...");
            try {
                AESExample aes = new AESExample();

                aes.testAESImplementationTwo();
		aes.testAESSlowerImplementationOne ();

            } catch (Exception ex) {
                ex.printStackTrace();
            }
            
    }
}